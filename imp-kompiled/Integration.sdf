module Integration

imports Common
imports KTechnique
imports KBuiltinsBasic

imports Variables

exports

context-free syntax
context-free priorities
{
    "notBool" Bool -> Bool {cons("Bool1253Syn")}
} > {
    Bool "andBool" Bool -> Bool {left, cons("Bool1328Syn")}
    K "andThenBool" K -> Bool {left, cons("Bool1499Syn")}
} > {
    Bool "xorBool" Bool -> Bool {left, cons("Bool179Syn")}
} > {
    Bool "orBool" Bool -> Bool {left, cons("Bool1488Syn")}
    K "orElseBool" K -> Bool {left, cons("Bool1323Syn")}
} > {
    Bool "impliesBool" Bool -> Bool {left, cons("Bool1577Syn")}
} > { left:
    Bool "==Bool" Bool -> Bool {left, cons("Bool1260Syn")}
    Bool "=/=Bool" Bool -> Bool {left, cons("Bool1538Syn")}
}

context-free priorities
{
    K "|->" K -> Map {cons("Map1383Syn")}
} > {
    Map Map -> Map {left, cons("Map1428Syn")}
}

context-free priorities
{ left:
    K "==K" K -> Bool {left, cons("Bool1332Syn")}
    K "=/=K" K -> Bool {left, cons("Bool1392Syn")}
}

context-free priorities
{
    K "==K" K -> Bool {left, cons("Bool1332Syn")}
    Bag "==Bag" Bag -> Bool {left, cons("Bool1363Syn")}
    Bag "=/=Bag" Bag -> Bool {left, cons("Bool1233Syn")}
    K "=/=K" K -> Bool {left, cons("Bool1392Syn")}
} > {
    Bool "impliesBool" Bool -> Bool {left, cons("Bool1577Syn")}
    "notBool" Bool -> Bool {cons("Bool1253Syn")}
    K "andThenBool" K -> Bool {left, cons("Bool1499Syn")}
    Bool "orBool" Bool -> Bool {left, cons("Bool1488Syn")}
    K "orElseBool" K -> Bool {left, cons("Bool1323Syn")}
    Bool "xorBool" Bool -> Bool {left, cons("Bool179Syn")}
    Bool "andBool" Bool -> Bool {left, cons("Bool1328Syn")}
}

context-free priorities
{ left:
    Bag "==Bag" Bag -> Bool {left, cons("Bool1363Syn")}
    Bag "=/=Bag" Bag -> Bool {left, cons("Bool1233Syn")}
}

context-free priorities
{
    "~Int" Int -> Int {cons("Int193Syn")}
} > { left:
    Int "^Int" Int -> Int {left, cons("Int150Syn")}
} > { left:
    Int "*Int" Int -> Int {left, cons("Int1380Syn")}
    Int "/Int" Int -> Int {left, cons("Int1404Syn")}
    Int "%Int" Int -> Int {left, cons("Int1236Syn")}
    Int "divInt" Int -> Int {left, cons("Int1280Syn")}
    Int "modInt" Int -> Int {left, cons("Int1382Syn")}
} > { left:
    Int "+Int" Int -> Int {left, cons("Int1496Syn")}
    Int "-Int" Int -> Int {left, cons("Int1205Syn")}
} > { left:
    Int ">>Int" Int -> Int {left, cons("Int182Syn")}
    Int "<<Int" Int -> Int {left, cons("Int1435Syn")}
} > { left:
    Int "&Int" Int -> Int {left, cons("Int192Syn")}
} > { left:
    Int "xorInt" Int -> Int {left, cons("Int162Syn")}
} > { left:
    Int "|Int" Int -> Int {left, cons("Int160Syn")}
}

context-free priorities
{
    "--Float" Float -> Float {cons("Float1493Syn")}
} > {
    Float "^Float" Float -> Float {left, cons("Float16Syn")}
} > {
    Float "*Float" Float -> Float {left, cons("Float1422Syn")}
    Float "/Float" Float -> Float {left, cons("Float148Syn")}
    Float "%Float" Float -> Float {left, cons("Float1277Syn")}
} > {
    Float "+Float" Float -> Float {left, cons("Float1337Syn")}
    Float "-Float" Float -> Float {left, cons("Float1494Syn")}
}

context-free priorities
{
    Int -> AExp {}
    Id -> AExp {}
    AExp "**" AExp -> AExp {left, cons("AExp1484Syn")}
} > {
    AExp "*" AExp -> AExp {left, cons("AExp1288Syn")}
    AExp "/" AExp -> AExp {left, cons("AExp1343Syn")}
} > {
    AExp "+" AExp -> AExp {left, cons("AExp1375Syn")}
    AExp "-" AExp -> AExp {left, cons("AExp1362Syn")}
}

context-free priorities
{
    Bool -> BExp {}
    Id -> BExp {}
    RangeInt -> BExp {}
    RangeString -> BExp {}
    Exps "==" Exps -> BExp {left, cons("BExp1473Syn")}
    Exps ">" Exps -> BExp {left, cons("BExp1263Syn")}
    Exps "<" Exps -> BExp {left, cons("BExp1292Syn")}
    Exps ">=" Exps -> BExp {left, cons("BExp180Syn")}
    Exps "<=" Exps -> BExp {left, cons("BExp1459Syn")}
    Exps "!=" Exps -> BExp {left, cons("BExp1242Syn")}
    ExclamationMarkDz BExp -> BExp {cons("BExp184Syn")}
    "NOT" BExp -> BExp {cons("BExp1385Syn")}
    Exps "IS" "EQUAL TO" Exps -> BExp {left, cons("BExp190Syn")}
    Exps "IS" "GREATER THAN" Exps -> BExp {left, cons("BExp18Syn")}
    Exps "IS" "LESS THAN" Exps -> BExp {left, cons("BExp1320Syn")}
    Exps "IS" "GREATER THAN" "OR" "EQUAL TO" Exps -> BExp {left, cons("BExp125Syn")}
    Exps "IS" "LESS THAN" "OR" "EQUAL TO" Exps -> BExp {left, cons("BExp1273Syn")}
    Exps "IS" "=" Exps -> BExp {left, cons("BExp1232Syn")}
    Exps "IS" ">" Exps -> BExp {left, cons("BExp1259Syn")}
    Exps "IS" "<" Exps -> BExp {left, cons("BExp1246Syn")}
    Exps "IS" ">=" Exps -> BExp {left, cons("BExp1495Syn")}
    Exps "IS" "<=" Exps -> BExp {left, cons("BExp1470Syn")}
    Exps "IS" "NOT" "EQUAL TO" Exps -> BExp {left, cons("BExp1300Syn")}
    Exps "IS" "NOT" "GREATER THAN" Exps -> BExp {left, cons("BExp1449Syn")}
    Exps "IS" "NOT" "LESS THAN" Exps -> BExp {left, cons("BExp1286Syn")}
    Exps "IS" "NOT" "=" Exps -> BExp {left, cons("BExp1298Syn")}
    Exps "IS" "NOT" ">" Exps -> BExp {left, cons("BExp129Syn")}
    Exps "IS" "NOT" "<" Exps -> BExp {left, cons("BExp1278Syn")}
    AExp "IS" "POSITIVE" -> BExp {cons("BExp1228Syn")}
    AExp "IS" "NEGATIVE" -> BExp {cons("BExp1403Syn")}
    AExp "IS" "ZERO" -> BExp {cons("BExp1568Syn")}
    AExp "IS" "NOT" "POSITIVE" -> BExp {cons("BExp1378Syn")}
    AExp "IS" "NOT" "NEGATIVE" -> BExp {cons("BExp1243Syn")}
    AExp "IS" "NOT" "ZERO" -> BExp {cons("BExp1282Syn")}
    Exps "IS" "NUMERIC" -> BExp {cons("BExp1588Syn")}
    Exps "IS" "ALPHABETIC" -> BExp {cons("BExp1462Syn")}
    Exps "IS" "ALPHABETIC-LOWER" -> BExp {cons("BExp1306Syn")}
    Exps "IS" "ALPHABETIC-UPPER" -> BExp {cons("BExp186Syn")}
    Exps "IS" "NOT" "NUMERIC" -> BExp {cons("BExp1234Syn")}
    Exps "IS" "NOT" "ALPHABETIC" -> BExp {cons("BExp1447Syn")}
    Exps "IS" "NOT" "ALPHABETIC-LOWER" -> BExp {cons("BExp147Syn")}
    Exps "IS" "NOT" "ALPHABETIC-UPPER" -> BExp {cons("BExp1285Syn")}
} > {
    BExp "AND" BExp -> BExp {left, cons("BExp1466Syn")}
    BExp "&&" BExp -> BExp {left, cons("BExp1530Syn")}
    BExp "OR" BExp -> BExp {left, cons("BExp1325Syn")}
    BExp "||" BExp -> BExp {left, cons("BExp1553Syn")}
}

%% subsorts 1
context-free priorities
{
    Nat -> K
    AExp -> K
    Set -> K
    Variable -> K
    Stmts -> K
    MInt -> K
    LowerCase -> K
    CamelCaseId -> K
    String -> K
    Int -> K
    Stmt -> K
    Bool -> K
    Char -> K
    Ids -> K
    List -> K
    Stream -> K
    TCPAnswer -> K
    DzInt -> K
    DzString -> K
    DzBool -> K
    PascalCaseId -> K
    Blocks -> K
    UpperCase -> K
    BExp -> K
    RangeString -> K
    SExp -> K
    TCPError -> K
    CondName -> K
    Float -> K
    IOError -> K
    Exps -> K
    Pgm -> K
    Block -> K
    Id -> K
    Map -> K
    RangeInt -> K
    DzFloat -> K
} .> {
    RangeInt -> BExp
    TCPError -> TCPAnswer
    DzInt -> Int
    Id -> AExp
    Block -> Blocks
    AExp -> Exps
    RangeString -> BExp
    Id -> Ids
    String -> SExp
    Blocks -> Pgm
    DzBool -> Bool
    Stmt -> Stmts
    DzFloat -> Float
    Id -> SExp
    SExp -> Exps
    IOError -> TCPError
    Id -> BExp
    Block -> Stmt
    DzString -> String
    String -> TCPAnswer
    Int -> AExp
    Bool -> BExp
    Blocks -> Stmts
} .> {
    K -> Nat
    K -> AExp
    K -> Set
    K -> Variable
    K -> Stmts
    K -> MInt
    K -> LowerCase
    K -> CamelCaseId
    K -> String
    K -> Int
    K -> Stmt
    K -> Bool
    K -> Char
    K -> Ids
    K -> List
    K -> Stream
    K -> TCPAnswer
    K -> DzInt
    K -> DzString
    K -> DzBool
    K -> PascalCaseId
    K -> Blocks
    K -> UpperCase
    K -> BExp
    K -> RangeString
    K -> SExp
    K -> TCPError
    K -> CondName
    K -> Float
    K -> IOError
    K -> Exps
    K -> Pgm
    K -> Block
    K -> Id
    K -> Map
    K -> RangeInt
    K -> DzFloat
}

%% subsorts 1a
context-free priorities
{
    Nat -> K
    AExp -> K
    Set -> K
    Variable -> K
    Stmts -> K
    MInt -> K
    LowerCase -> K
    CamelCaseId -> K
    String -> K
    Int -> K
    Stmt -> K
    Bool -> K
    Char -> K
    Ids -> K
    List -> K
    Stream -> K
    TCPAnswer -> K
    DzInt -> K
    DzString -> K
    DzBool -> K
    PascalCaseId -> K
    Blocks -> K
    UpperCase -> K
    BExp -> K
    RangeString -> K
    SExp -> K
    TCPError -> K
    CondName -> K
    Float -> K
    IOError -> K
    Exps -> K
    Pgm -> K
    Block -> K
    Id -> K
    Map -> K
    RangeInt -> K
    DzFloat -> K
} .> {
    K -> Nat
    K -> AExp
    K -> Set
    K -> Variable
    K -> Stmts
    K -> MInt
    K -> LowerCase
    K -> CamelCaseId
    K -> String
    K -> Int
    K -> Stmt
    K -> Bool
    K -> Char
    K -> Ids
    K -> List
    K -> Stream
    K -> TCPAnswer
    K -> DzInt
    K -> DzString
    K -> DzBool
    K -> PascalCaseId
    K -> Blocks
    K -> UpperCase
    K -> BExp
    K -> RangeString
    K -> SExp
    K -> TCPError
    K -> CondName
    K -> Float
    K -> IOError
    K -> Exps
    K -> Pgm
    K -> Block
    K -> Id
    K -> Map
    K -> RangeInt
    K -> DzFloat
}

%% subsorts 2
context-free priorities
{
    K -> Nat
    K -> AExp
    K -> Set
    K -> Variable
    K -> Stmts
    K -> MInt
    K -> LowerCase
    K -> CamelCaseId
    K -> String
    K -> Int
    K -> Stmt
    K -> Bool
    K -> Char
    K -> Ids
    K -> List
    K -> Stream
    K -> TCPAnswer
    K -> DzInt
    K -> DzString
    K -> DzBool
    K -> PascalCaseId
    K -> Blocks
    K -> UpperCase
    K -> BExp
    K -> RangeString
    K -> SExp
    K -> TCPError
    K -> CondName
    K -> Float
    K -> IOError
    K -> Exps
    K -> Pgm
    K -> Block
    K -> Id
    K -> Map
    K -> RangeInt
    K -> DzFloat
} .> {
    Nat -> K
    AExp -> K
    Set -> K
    Variable -> K
    Stmts -> K
    MInt -> K
    LowerCase -> K
    CamelCaseId -> K
    String -> K
    Int -> K
    Stmt -> K
    Bool -> K
    Char -> K
    Ids -> K
    List -> K
    Stream -> K
    TCPAnswer -> K
    DzInt -> K
    DzString -> K
    DzBool -> K
    PascalCaseId -> K
    Blocks -> K
    UpperCase -> K
    BExp -> K
    RangeString -> K
    SExp -> K
    TCPError -> K
    CondName -> K
    Float -> K
    IOError -> K
    Exps -> K
    Pgm -> K
    Block -> K
    Id -> K
    Map -> K
    RangeInt -> K
    DzFloat -> K
}
context-free syntax
    "uleMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool10Syn")}
    "#buffer" "(" InsertDzK ")" -> Stream {cons("Stream1345Syn")}
    "#counter" -> Int {cons("Int12Syn")}
    "#read" "(" InsertDzInt "," InsertDzInt ")" -> KItem {cons("KItem13Syn")}
    SExp "+" SExp -> SExp {left, cons("SExp14Syn")}
    K "inKList" KList -> Bool {cons("Bool1346Syn")}
    "sgeMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1347Syn")}
    "findChar" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int15Syn")}
    "isKLabelConstant" "(" InsertDzKLabel ")" -> Bool {cons("Bool1348Syn")}
    RangeString -> KItem {}
    "88" InsertDzId "VALUE" "IS" InsertDzInt "." -> CondName {cons("CondName1349Syn")}
    "#EISDIR" -> IOError {cons("IOError1350Syn")}
    "K2Sort" "(" InsertDzK ")" -> String {cons("String1352Syn")}
    "removeAll" "(" InsertDzMap "," InsertDzSet ")" -> Map {cons("Map17Syn")}
    "isVariable" "(" InsertDzMap ")" -> Bool {cons("Bool1353Syn")}
    "#string2klist" "(" InsertDzString ")" -> KList {cons("KList1354Syn")}
    Map "[" InsertDzK "<-" InsertDzK "]" -> Map {cons("Map1355Syn")}
    "sqrtFloat" "(" InsertDzFloat ")" -> Float {cons("Float1356Syn")}
    Map "=Map" Map -> Bool {cons("Bool19Syn")}
    "sinFloat" "(" InsertDzFloat ")" -> Float {cons("Float1357Syn")}
    Set "=Set" Set -> Bool {cons("Bool120Syn")}
    String "<String" String -> Bool {cons("Bool1358Syn")}
    "88" InsertDzId "VALUE" InsertDzInt "." -> CondName {cons("CondName1359Syn")}
    "values" "(" InsertDzMap ")" -> List {cons("List122Syn")}
    "roundFloat" "(" InsertDzFloat "," InsertDzInt "," InsertDzInt ")" -> Float {cons("Float1360Syn")}
    "bool" InsertDzIds ";" -> Stmt {cons("Stmt123Syn")}
    "IF" InsertDzBExp "THEN" InsertDzStmts "ELSE" InsertDzStmts "END-IF" -> Stmt {cons("Stmt124Syn")}
    ".List" -> List {cons("List126Syn")}
    "#freshSymSortN" "(" InsertDzString "," InsertDzInt ")" -> K {cons("K127Syn")}
    "addMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1364Syn")}
    "int" InsertDzId ";" CondName -> Stmt {cons("Stmt128Syn")}
    "#EBADF" -> IOError {cons("IOError1365Syn")}
    "#ostream" "(" InsertDzInt ")" -> Stream {cons("Stream130Syn")}
    "KLabel2String" "(" InsertDzKLabel ")" -> String {cons("String132Syn")}
    "isBuiltin" "(" InsertDzK ")" -> Bool {cons("Bool1366Syn")}
    "signFloat" "(" InsertDzFloat ")" -> Bool {cons("Bool1367Syn")}
    "#stderr" -> Int {cons("Int1368Syn")}
    "miMInt" "(" InsertDzList ")" -> MInt {cons("MInt133Syn")}
    "isKResult" "(" InsertDzKItem ")" -> Bool {cons("Bool134Syn")}
    "88" InsertDzId "VALUE" "IS" InsertDzString "." -> CondName {cons("CondName135Syn")}
    "exponentFloat" "(" InsertDzFloat ")" -> Int {cons("Int136Syn")}
    Map "-Map" Map -> Map {cons("Map1369Syn")}
    TCPError -> TCPAnswer {}
    "#checkTCPAnswer" "(" InsertDzString ")" -> TCPAnswer {cons("TCPAnswer1370Syn")}
    "ashrMInt" "(" InsertDzMInt "," InsertDzInt ")" -> MInt {cons("MInt137Syn")}
    "categoryChar" "(" InsertDzString ")" -> String {cons("String1372Syn")}
    "substrString" "(" InsertDzString "," InsertDzInt "," InsertDzInt ")" -> String {cons("String138Syn")}
    "saddMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List139Syn")}
    Set "-Set" Set -> Set {cons("Set140Syn")}
    Int "dividesInt" Int -> Bool {cons("Bool1373Syn")}
    "String2KLabel" "(" InsertDzString ")" -> KLabel {cons("KLabel142Syn")}
    "isBounding" "(" InsertDzKLabel "," InsertDzInt ")" -> Bool {cons("Bool1374Syn")}
    "#parseInput" "(" InsertDzString "," InsertDzString ")" -> Stream {cons("Stream143Syn")}
    "#boundVars" "(" InsertDzK ")" -> K {cons("K1376Syn")}
    Id "=" InsertDzBExp ";" -> Stmt {cons("Stmt144Syn")}
    "88" InsertDzId "VALUES" "ARE" InsertDzInt "THRU" InsertDzInt "." -> CondName {cons("CondName1377Syn")}
    String "=/=String" String -> Bool {left, cons("Bool145Syn")}
    "freshId" "(" InsertDzInt ")" -> Id {cons("Id146Syn")}
    DzInt -> Int {}
    "#freezer" K -> KLabel {cons("KLabel1379Syn")}
    "ordChar" "(" InsertDzString ")" -> Int {cons("Int149Syn")}
    "#distinctCounter" "(" InsertDzInt ")" -> Int {cons("Int152Syn")}
    K "|->" K -> Map {cons("Map1383Syn")}
    "freshInt" "(" InsertDzInt ")" -> Int {cons("Int153Syn")}
    "size" "(" InsertDzList ")" -> Int {cons("Int1384Syn")}
    "int" InsertDzIds ";" -> Stmt {cons("Stmt154Syn")}
    "andMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1386Syn")}
    Id "=" InsertDzExps ";" -> Stmt {cons("Stmt1387Syn")}
    "updateMap" "(" InsertDzMap "," InsertDzMap ")" -> Map {cons("Map155Syn")}
    Int "=Int" Int -> Bool {cons("Bool1388Syn")}
    "ListItem" "(" InsertDzK ")" -> List {cons("List156Syn")}
    "String2Bag" "(" InsertDzString ")" -> Bag {cons("Bag157Syn")}
    "expFloat" "(" InsertDzFloat ")" -> Float {cons("Float158Syn")}
    "rfindChar" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1389Syn")}
    "acosFloat" "(" InsertDzFloat ")" -> Float {cons("Float1390Syn")}
    "(" InsertDzInt "," InsertDzInt ")" -> RangeInt {cons("RangeInt159Syn")}
    "isSymbolicK" "(" InsertDzList ")" -> KItem {cons("KItem1393Syn")}
    "#lstat" "(" InsertDzString ")" -> KList {cons("KList1394Syn")}
    "shlMInt" "(" InsertDzMInt "," InsertDzInt ")" -> MInt {cons("MInt163Syn")}
    "trim" "(" InsertDzString ")" -> String {cons("String1395Syn")}
    "#parseInModule" "(" InsertDzString "," InsertDzString "," InsertDzString ")" -> KItem {cons("KItem1396Syn")}
    "ugeMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool164Syn")}
    "maxFloat" "(" InsertDzFloat "," InsertDzFloat ")" -> Float {cons("Float165Syn")}
    "#statTypes" "(" InsertDzKList ")" -> KList {cons("KList166Syn")}
    "#opendir" "(" InsertDzString ")" -> KList {cons("KList167Syn")}
    "string" InsertDzIds ";" -> Stmt {cons("Stmt168Syn")}
    Int "<Int" Int -> Bool {left, cons("Bool1397Syn")}
    KLabel "=KLabel" KLabel -> Bool {cons("Bool169Syn")}
    "exponentBitsFloat" "(" InsertDzFloat ")" -> Int {cons("Int170Syn")}
    "absInt" "(" InsertDzInt ")" -> Int {cons("Int172Syn")}
    "#tcpRequest" "(" InsertDzString ")" -> TCPAnswer {cons("TCPAnswer1399Syn")}
    "String2Float" "(" InsertDzString ")" -> Float {cons("Float1400Syn")}
    "mi" "(" InsertDzInt "," InsertDzInt ")" -> MInt {cons("MInt173Syn")}
    "smaxMInt" "(" InsertDzInt ")" -> Int {cons("Int174Syn")}
    "uoverflowMInt" "(" InsertDzInt "," InsertDzInt ")" -> Bool {cons("Bool175Syn")}
    "#freshSymN" "(" InsertDzK "," InsertDzInt ")" -> K {cons("K1402Syn")}
    IOError -> TCPError {}
    "#string2Int" "(" InsertDzK ")" -> K {cons("K1405Syn")}
    "88" InsertDzId "VALUE" InsertDzString "." CondName -> CondName {cons("CondName177Syn")}
    "Float2Int" "(" InsertDzFloat ")" -> Int {cons("Int1406Syn")}
    "cool" "(" InsertDzK ")" -> K {cons("K178Syn")}
    "isVariable" "(" InsertDzSet ")" -> Bool {cons("Bool1407Syn")}
    "range" "(" InsertDzList "," InsertDzInt "," InsertDzInt ")" -> List {cons("List1408Syn")}
    "rtrim" "(" InsertDzString ")" -> String {cons("String1409Syn")}
    "bitwidthMInt" "(" InsertDzMInt ")" -> Int {cons("Int1420Syn")}
    "String2Bool" "(" InsertDzTCPAnswer ")" -> Bool {cons("Bool183Syn")}
    "cosFloat" "(" InsertDzFloat ")" -> Float {cons("Float1423Syn")}
    "chrChar" "(" InsertDzInt ")" -> String {cons("String1424Syn")}
    "directionalityChar" "(" InsertDzString ")" -> String {cons("String1425Syn")}
    DzBool -> Bool {}
    "isNaN" "(" InsertDzFloat ")" -> Bool {cons("Bool185Syn")}
    Set "<=Set" Set -> Bool {cons("Bool187Syn")}
    KList "=KList" KList -> Bool {cons("Bool1426Syn")}
    Float ">=Float" Float -> Bool {left, cons("Bool1427Syn")}
    Map Map -> Map {left, cons("Map1428Syn")}
    Float "<Float" Float -> Bool {left, cons("Bool1429Syn")}
    "negMInt" "(" InsertDzMInt ")" -> MInt {cons("MInt188Syn")}
    "atan2Float" "(" InsertDzFloat "," InsertDzFloat ")" -> Float {cons("Float1430Syn")}
    "Float2String" "(" InsertDzFloat ")" -> String {cons("String1432Syn")}
    "udivMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1433Syn")}
    "#putc" "(" InsertDzInt "," InsertDzInt ")" -> K {cons("K189Syn")}
    "randomRandom" "(" InsertDzInt ")" -> Int {cons("Int1434Syn")}
    "#noIO" -> Stream {cons("Stream1436Syn")}
    Float "=/=Float" Float -> Bool {left, cons("Bool1437Syn")}
    "#tokenToString" "(" InsertDzK ")" -> String {cons("String1438Syn")}
    "isCollection" "(" InsertDzK ")" -> K {cons("K1439Syn")}
    "#freshVar" "(" InsertDzK "," InsertDzSet ")" -> K {cons("K1440Syn")}
    "#EACCES" -> IOError {cons("IOError1442Syn")}
    "subMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1443Syn")}
    List "=List" List -> Bool {cons("Bool194Syn")}
    "isLocalFreshVar" "(" InsertDzK ")" -> Bool {cons("Bool1444Syn")}
    "#parse" "(" InsertDzString "," InsertDzString ")" -> KItem {cons("KItem1445Syn")}
    "intersectSet" "(" InsertDzSet "," InsertDzSet ")" -> Set {cons("Set1446Syn")}
    "88" InsertDzId "VALUE" "IS" InsertDzInt "." CondName -> CondName {cons("CondName195Syn")}
    "Base2String" "(" InsertDzInt "," InsertDzInt ")" -> String {cons("String1448Syn")}
    "findString" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int196Syn")}
    "Int2String" "(" InsertDzInt ")" -> String {cons("String197Syn")}
    Set Set -> Set {left, cons("Set1450Syn")}
    "sminMInt" "(" InsertDzInt ")" -> Int {cons("Int1452Syn")}
    Map "[" InsertDzK "]" -> K {cons("K199Syn")}
    "ltrim" "(" InsertDzString ")" -> String {cons("String1453Syn")}
    "ssubMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1200Syn")}
    "SMTLibQuery" "(" InsertDzBool ")" -> String {cons("String1454Syn")}
    "(" InsertDzString "," InsertDzString ")" -> RangeString {cons("RangeString1455Syn")}
    "#write" "(" InsertDzInt "," InsertDzString ")" -> K {cons("K1456Syn")}
    "xorMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1202Syn")}
    Id "," Ids -> Ids {cons("Ids1ListSyn")}
    ".Ids" -> Ids {cons("Ids1Empty")}
    K "#inKList" KList -> Bool {cons("Bool1457Syn")}
    "Vars2SMTLib" "(" InsertDzSet ")" -> String {cons("String1203Syn")}
    "rootFloat" "(" InsertDzFloat "," InsertDzInt ")" -> Float {cons("Float1458Syn")}
    "absFloat" "(" InsertDzFloat ")" -> Float {cons("Float1460Syn")}
    "isSymbolicBag" "(" InsertDzBag ")" -> KItem {cons("KItem1204Syn")}
    "Bag2String" "(" InsertDzBag ")" -> String {cons("String1206Syn")}
    "#if" InsertDzBool "#then" InsertDzK "#else" InsertDzK "#fi" -> K {cons("K1463Syn")}
    "#isWhiteSpace" "(" InsertDzString ")" -> Bool {cons("Bool1207Syn")}
    "SMTCall" "(" InsertDzString ")" -> String {cons("String1464Syn")}
    "SetItem" "(" InsertDzK ")" -> Set {cons("Set1465Syn")}
    "logFloat" "(" InsertDzFloat ")" -> Float {cons("Float1208Syn")}
    "#getVars1" "(" InsertDzKList "," InsertDzSet ")" -> Set {cons("Set1209Syn")}
    Blocks -> Pgm {}
    "uremMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1467Syn")}
    "#open" "(" InsertDzString "," InsertDzString ")" -> KItem {cons("KItem1220Syn")}
    "choice" "(" InsertDzSet ")" -> K {cons("K1468Syn")}
    KLabel "==KLabel" KLabel -> Bool {cons("Bool1222Syn")}
    "String2Int" "(" InsertDzString ")" -> Int {cons("Int1469Syn")}
    "#binderSplit" "(" InsertDzK ")" -> K {cons("K1223Syn")}
    "mIntOfDigits" "(" InsertDzList ")" -> MInt {cons("MInt1224Syn")}
    KList "=/=KList" KList -> Bool {cons("Bool1225Syn")}
    "K2String" "(" InsertDzK ")" -> String {cons("String1472Syn")}
    "ugtMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1226Syn")}
    Int "=/=Int" Int -> Bool {left, cons("Bool1474Syn")}
    "zeroMInt" "(" InsertDzMInt ")" -> Bool {cons("Bool1475Syn")}
    "uminMInt" "(" InsertDzInt ")" -> Int {cons("Int1227Syn")}
    "#isDigit" "(" InsertDzString ")" -> Bool {cons("Bool1229Syn")}
    "#systemTypes" "(" InsertDzKList ")" -> KItem {cons("KItem1476Syn")}
    DzString -> String {}
    Stmt "" Stmts -> Stmts {cons("Stmts1ListSyn")}
    ".Stmts" -> Stmts {cons("Stmts1Empty")}
    "fpNaN" "(" InsertDzInt "," InsertDzInt ")" -> Float {cons("Float1230Syn")}
    "isBound" "(" InsertDzKLabel "," InsertDzInt ")" -> Bool {cons("Bool1478Syn")}
    "fresh" "(" InsertDzString ")" -> KItem {cons("KItem1479Syn")}
    "isVariable" "(" InsertDzBag ")" -> Bool {cons("Bool1480Syn")}
    "Consts2SMTLib" "(" InsertDzSet ")" -> String {cons("String1482Syn")}
    DzFloat -> Float {}
    "neMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1235Syn")}
    "rfindString" "(" InsertDzString "," InsertDzString "," InsertDzInt ")" -> Int {cons("Int1483Syn")}
    "Id2String" "(" InsertDzId ")" -> String {cons("String1237Syn")}
    "#ELOOP" -> IOError {cons("IOError1238Syn")}
    "String2Base" "(" InsertDzString "," InsertDzInt ")" -> Int {cons("Int1239Syn")}
    "keys" "(" InsertDzMap ")" -> Set {cons("Set1240Syn")}
    "#systemResult" "(" InsertDzInt "," InsertDzString "," InsertDzString ")" -> KItem {cons("KItem1485Syn")}
    "#stdin" -> Int {cons("Int1486Syn")}
    "##tcpRequest" "(" InsertDzString ")" -> String {cons("String1487Syn")}
    "maxInt" "(" InsertDzInt "," InsertDzInt ")" -> Int {cons("Int1489Syn")}
    "K2SMTLib" "(" InsertDzK ")" -> String {cons("String1490Syn")}
    "lengthString" "(" InsertDzString ")" -> Int {cons("Int1492Syn")}
    "#parseToken" "(" InsertDzString "," InsertDzString ")" -> KItem {cons("KItem1244Syn")}
    "uvalueMInt" "(" InsertDzMInt ")" -> Int {cons("Int1497Syn")}
    "smulMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1245Syn")}
    AExp -> Exps {}
    "#system" "(" InsertDzString ")" -> KItem {cons("KItem1500Syn")}
    "string" InsertDzId ";" CondName -> Stmt {cons("Stmt1502Syn")}
    "#stat" "(" InsertDzString ")" -> KList {cons("KList1247Syn")}
    "ultMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1248Syn")}
    Float "<=Float" Float -> Bool {left, cons("Bool1503Syn")}
    "tanFloat" "(" InsertDzFloat ")" -> Float {cons("Float1504Syn")}
    "svalueMInt" "(" InsertDzMInt ")" -> Int {cons("Int1505Syn")}
    "replace" "(" InsertDzString "," InsertDzString "," InsertDzString "," InsertDzInt ")" -> String {cons("String1506Syn")}
    ".Set" -> Set {cons("Set1507Syn")}
    "sgtMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1249Syn")}
    "#close" "(" InsertDzInt ")" -> K {cons("K1250Syn")}
    "minInt" "(" InsertDzInt "," InsertDzInt ")" -> Int {cons("Int1252Syn")}
    List List -> List {left, cons("List1508Syn")}
    "88" InsertDzId "VALUES" InsertDzInt "THRU" InsertDzInt "." -> CondName {cons("CondName1509Syn")}
    "sMinMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1254Syn")}
    Map "<=Map" Map -> Bool {cons("Bool1255Syn")}
    String -> SExp {}
    Int ">Int" Int -> Bool {left, cons("Bool1520Syn")}
    "String2Id" "(" InsertDzString ")" -> Id {cons("Id1522Syn")}
    "ceilFloat" "(" InsertDzFloat ")" -> Float {cons("Float1256Syn")}
    "#ENOTDIR" -> IOError {cons("IOError1257Syn")}
    String "==String" String -> Bool {left, cons("Bool1258Syn")}
    "atanFloat" "(" InsertDzFloat ")" -> Float {cons("Float1523Syn")}
    String "+String" String -> String {left, cons("String1262Syn")}
    Id -> SExp {}
    String ">=String" String -> Bool {cons("Bool1524Syn")}
    "sdivMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1525Syn")}
    K "in" Set -> Bool {cons("Bool1264Syn")}
    Int "<=Int" Int -> Bool {left, cons("Bool1526Syn")}
    ".Map" -> Map {cons("Map1265Syn")}
    KLabel "=/=KLabel" KLabel -> Bool {cons("Bool1266Syn")}
    KList "==KList" KList -> Bool {cons("Bool1267Syn")}
    Int "==Int" Int -> Bool {left, cons("Bool1527Syn")}
    String -> TCPAnswer {}
    "Char2String" "(" InsertDzChar ")" -> String {cons("String1528Syn")}
    "88" InsertDzId "VALUES" "ARE" InsertDzInt "THRU" InsertDzInt "." CondName -> CondName {cons("CondName1269Syn")}
    "replaceAll" "(" InsertDzString "," InsertDzString "," InsertDzString ")" -> String {cons("String1270Syn")}
    Int ">=Int" Int -> Bool {left, cons("Bool1529Syn")}
    "concatenateMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1272Syn")}
    "lshrMInt" "(" InsertDzMInt "," InsertDzInt ")" -> MInt {cons("MInt1532Syn")}
    "sltMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1533Syn")}
    "digitsOfMInt" "(" InsertDzMInt "," InsertDzInt "," InsertDzInt ")" -> List {cons("List1534Syn")}
    "#ENOENT" -> IOError {cons("IOError1535Syn")}
    "88" InsertDzId "VALUE" "IS" InsertDzString "." CondName -> CondName {cons("CondName1536Syn")}
    "usubMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1537Syn")}
    "#EINVAL" -> IOError {cons("IOError1539Syn")}
    String ">String" String -> Bool {cons("Bool1540Syn")}
    "umaxMInt" "(" InsertDzInt ")" -> Int {cons("Int1542Syn")}
    Bag "=Bag" Bag -> Bool {cons("Bool1274Syn")}
    "isToken" "(" InsertDzK ")" -> Bool {cons("Bool1543Syn")}
    "sremMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1544Syn")}
    "floorFloat" "(" InsertDzFloat ")" -> Float {cons("Float1275Syn")}
    "#freshSym" "(" InsertDzK ")" -> K {cons("K1545Syn")}
    "precisionFloat" "(" InsertDzFloat ")" -> Int {cons("Int1276Syn")}
    List "[" InsertDzInt "]" -> K {cons("K1546Syn")}
    "String2Char" "(" InsertDzString ")" -> Char {cons("Char1547Syn")}
    "String2K" "(" InsertDzString ")" -> K {cons("K1279Syn")}
    "getVariables" "(" InsertDzK ")" -> Set {cons("Set1548Syn")}
    "#stdout" -> Int {cons("Int1549Syn")}
    Block "" Blocks -> Blocks {cons("Blocks1ListSyn")}
    ".Blocks" -> Blocks {cons("Blocks1Empty")}
    "#tcpError" "(" InsertDzString ")" -> TCPError {cons("TCPError1550Syn")}
    "#noparse" -> IOError {cons("IOError1552Syn")}
    Float ">Float" Float -> Bool {left, cons("Bool1283Syn")}
    "extractMInt" "(" InsertDzMInt "," InsertDzInt "," InsertDzInt ")" -> MInt {cons("MInt1554Syn")}
    Exps ";" -> Stmt {cons("Stmt1284Syn")}
    "checkSat" "(" InsertDzBool ")" -> String {cons("String1556Syn")}
    "exists" InsertDzSet "." Bool -> Bool {cons("Bool1287Syn")}
    "minusInfinity" "(" InsertDzInt "," InsertDzInt ")" -> Float {cons("Float1557Syn")}
    "88" InsertDzId "VALUE" InsertDzInt "." CondName -> CondName {cons("CondName1558Syn")}
    "Int2Float" "(" InsertDzInt "," InsertDzInt "," InsertDzInt ")" -> Float {cons("Float1560Syn")}
    "isVariable" "(" InsertDzList ")" -> Bool {cons("Bool1289Syn")}
    "$mi" "(" InsertDzInt "," InsertDzInt ")" -> MInt {cons("MInt1290Syn")}
    "#istream" "(" InsertDzInt ")" -> Stream {cons("Stream1562Syn")}
    "replaceFirst" "(" InsertDzString "," InsertDzString "," InsertDzString ")" -> String {cons("String1563Syn")}
    "#getVars" "(" InsertDzK ")" -> Set {cons("Set1564Syn")}
    "{" InsertDzStmts "}" -> Block {cons("Block1565Syn")}
    "freeVariables" "(" InsertDzKList ")" -> Set {cons("Set1293Syn")}
    "#getSymLabel" "(" InsertDzString ")" -> K {cons("K1566Syn")}
    "#freshVar1" "(" InsertDzSet "," InsertDzK ")" -> K {cons("K1294Syn")}
    Block -> Stmt {}
    KResult -> KItem {}
    "plusInfinity" "(" InsertDzInt "," InsertDzInt ")" -> Float {cons("Float1295Syn")}
    "#ENAMETOOLONG" -> IOError {cons("IOError1296Syn")}
    "significandFloat" "(" InsertDzFloat ")" -> MInt {cons("MInt1297Syn")}
    "getKLabel" K -> KLabel {cons("KLabel1567Syn")}
    "orMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1569Syn")}
    Float "==Float" Float -> Bool {left, cons("Bool1299Syn")}
    "size" "(" InsertDzMap ")" -> Int {cons("Int1302Syn")}
    "dummy" "(" InsertDzKList ")" -> KItem {cons("KItem1570Syn")}
    "bool2Int" "(" InsertDzBool ")" -> Int {cons("Int1572Syn")}
    "#getc" "(" InsertDzInt ")" -> KItem {cons("KItem1573Syn")}
    "sleMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1303Syn")}
    "#retrieveTCPError" "(" InsertDzString ")" -> String {cons("String1574Syn")}
    "#boundVars1" "(" InsertDzK ")" -> Set {cons("Set1304Syn")}
    "minFloat" "(" InsertDzFloat "," InsertDzFloat ")" -> Float {cons("Float1305Syn")}
    "umulMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1575Syn")}
    String "<=String" String -> Bool {cons("Bool1307Syn")}
    "#EOF" -> IOError {cons("IOError1576Syn")}
    "88" InsertDzId "VALUE" InsertDzString "." -> CondName {cons("CondName1308Syn")}
    "mulMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1309Syn")}
    "#tell" "(" InsertDzInt ")" -> KItem {cons("KItem1578Syn")}
    "#splitedBinder" "(" InsertDzKList "," InsertDzKList "," InsertDzSet ")" -> KItem {cons("KItem1322Syn")}
    "#open" "(" InsertDzString ")" -> KItem {cons("KItem1579Syn")}
    "choice" "(" InsertDzMap ")" -> K {cons("K1324Syn")}
    "countAllOccurences" "(" InsertDzString "," InsertDzString ")" -> Int {cons("Int1326Syn")}
    "#isTCPError" "(" InsertDzString ")" -> Bool {cons("Bool1327Syn")}
    "{" "}" -> Block {cons("Block1580Syn")}
    "overflowMInt" "(" InsertDzList ")" -> Bool {cons("Bool1582Syn")}
    "sMaxMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> MInt {cons("MInt1583Syn")}
    RangeInt -> KItem {}
    "soverflowMInt" "(" InsertDzInt "," InsertDzInt ")" -> Bool {cons("Bool1329Syn")}
    K "=K" K -> Bool {cons("Bool1330Syn")}
    "#binderSplit1" "(" InsertDzKLabel "," InsertDzInt "," InsertDzKList "," InsertDzKList "," InsertDzKList "," InsertDzSet ")" -> K {cons("K1584Syn")}
    "size" "(" InsertDzSet ")" -> Int {cons("Int1585Syn")}
    "#freshSymSort" "(" InsertDzString ")" -> K {cons("K1333Syn")}
    "#ESPIPE" -> IOError {cons("IOError1586Syn")}
    "uaddMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> List {cons("List1334Syn")}
    Map "[" InsertDzK "<-" "undef" "]" -> Map {cons("Map1335Syn")}
    "forall" InsertDzSet "." Bool -> Bool {cons("Bool1336Syn")}
    SExp -> Exps {}
    K "in" List -> Bool {cons("Bool1587Syn")}
    "String2DotK" "(" InsertDzTCPAnswer ")" -> K {cons("K1338Syn")}
    "#seek" "(" InsertDzInt "," InsertDzInt ")" -> K {cons("K1339Syn")}
    "88" InsertDzId "VALUES" InsertDzInt "THRU" InsertDzInt "." CondName -> CondName {cons("CondName1589Syn")}
    "eqMInt" "(" InsertDzMInt "," InsertDzMInt ")" -> Bool {cons("Bool1340Syn")}
    "#ioError" "(" InsertDzString ")" -> KItem {cons("KItem1342Syn")}
    "asinFloat" "(" InsertDzFloat ")" -> Float {cons("Float1344Syn")}
    Set    -> InsertDzSet
    Stmts    -> InsertDzStmts
    BExp    -> InsertDzBExp
    MInt    -> InsertDzMInt
    Bag    -> InsertDzBag
    K    -> InsertDzK
    String    -> InsertDzString
    KList    -> InsertDzKList
    Int    -> InsertDzInt
    KLabel    -> InsertDzKLabel
    Float    -> InsertDzFloat
    Bool    -> InsertDzBool
    Char    -> InsertDzChar
    Exps    -> InsertDzExps
    Ids    -> InsertDzIds
    List    -> InsertDzList
    Id    -> InsertDzId
    TCPAnswer    -> InsertDzTCPAnswer
    Map    -> InsertDzMap
    KItem    -> InsertDzKItem


    VARID  ":Nat"        -> NatDzVar            {cons("Nat12Var")}
    VARID  ":Nat{" TagListDz "}"        -> NatDzVar            {cons("Nat12VarAttr")}
    VARID  ":AExp"        -> AExpDzVar            {cons("AExp12Var")}
    VARID  ":AExp{" TagListDz "}"        -> AExpDzVar            {cons("AExp12VarAttr")}
    VARID  ":Set"        -> SetDzVar            {cons("Set12Var")}
    VARID  ":Set{" TagListDz "}"        -> SetDzVar            {cons("Set12VarAttr")}
    VARID  ":Variable"        -> VariableDzVar            {cons("Variable12Var")}
    VARID  ":Variable{" TagListDz "}"        -> VariableDzVar            {cons("Variable12VarAttr")}
    VARID  ":Stmts"        -> StmtsDzVar            {cons("Stmts12Var")}
    VARID  ":Stmts{" TagListDz "}"        -> StmtsDzVar            {cons("Stmts12VarAttr")}
    VARID  ":MInt"        -> MIntDzVar            {cons("MInt12Var")}
    VARID  ":MInt{" TagListDz "}"        -> MIntDzVar            {cons("MInt12VarAttr")}
    VARID  ":LowerCase"        -> LowerCaseDzVar            {cons("LowerCase12Var")}
    VARID  ":LowerCase{" TagListDz "}"        -> LowerCaseDzVar            {cons("LowerCase12VarAttr")}
    VARID  ":CamelCaseId"        -> CamelCaseIdDzVar            {cons("CamelCaseId12Var")}
    VARID  ":CamelCaseId{" TagListDz "}"        -> CamelCaseIdDzVar            {cons("CamelCaseId12VarAttr")}
    VARID  ":String"        -> StringDzVar            {cons("String12Var")}
    VARID  ":String{" TagListDz "}"        -> StringDzVar            {cons("String12VarAttr")}
    VARID  ":Int"        -> IntDzVar            {cons("Int12Var")}
    VARID  ":Int{" TagListDz "}"        -> IntDzVar            {cons("Int12VarAttr")}
    VARID  ":Stmt"        -> StmtDzVar            {cons("Stmt12Var")}
    VARID  ":Stmt{" TagListDz "}"        -> StmtDzVar            {cons("Stmt12VarAttr")}
    VARID  ":Bool"        -> BoolDzVar            {cons("Bool12Var")}
    VARID  ":Bool{" TagListDz "}"        -> BoolDzVar            {cons("Bool12VarAttr")}
    VARID  ":Char"        -> CharDzVar            {cons("Char12Var")}
    VARID  ":Char{" TagListDz "}"        -> CharDzVar            {cons("Char12VarAttr")}
    VARID  ":Ids"        -> IdsDzVar            {cons("Ids12Var")}
    VARID  ":Ids{" TagListDz "}"        -> IdsDzVar            {cons("Ids12VarAttr")}
    VARID  ":List"        -> ListDzVar            {cons("List12Var")}
    VARID  ":List{" TagListDz "}"        -> ListDzVar            {cons("List12VarAttr")}
    VARID  ":Stream"        -> StreamDzVar            {cons("Stream12Var")}
    VARID  ":Stream{" TagListDz "}"        -> StreamDzVar            {cons("Stream12VarAttr")}
    VARID  ":TCPAnswer"        -> TCPAnswerDzVar            {cons("TCPAnswer12Var")}
    VARID  ":TCPAnswer{" TagListDz "}"        -> TCPAnswerDzVar            {cons("TCPAnswer12VarAttr")}
    VARID  ":#Int"        -> DzIntDzVar            {cons("DzInt12Var")}
    VARID  ":#Int{" TagListDz "}"        -> DzIntDzVar            {cons("DzInt12VarAttr")}
    VARID  ":#String"        -> DzStringDzVar            {cons("DzString12Var")}
    VARID  ":#String{" TagListDz "}"        -> DzStringDzVar            {cons("DzString12VarAttr")}
    VARID  ":#Bool"        -> DzBoolDzVar            {cons("DzBool12Var")}
    VARID  ":#Bool{" TagListDz "}"        -> DzBoolDzVar            {cons("DzBool12VarAttr")}
    VARID  ":PascalCaseId"        -> PascalCaseIdDzVar            {cons("PascalCaseId12Var")}
    VARID  ":PascalCaseId{" TagListDz "}"        -> PascalCaseIdDzVar            {cons("PascalCaseId12VarAttr")}
    VARID  ":Blocks"        -> BlocksDzVar            {cons("Blocks12Var")}
    VARID  ":Blocks{" TagListDz "}"        -> BlocksDzVar            {cons("Blocks12VarAttr")}
    VARID  ":UpperCase"        -> UpperCaseDzVar            {cons("UpperCase12Var")}
    VARID  ":UpperCase{" TagListDz "}"        -> UpperCaseDzVar            {cons("UpperCase12VarAttr")}
    VARID  ":BExp"        -> BExpDzVar            {cons("BExp12Var")}
    VARID  ":BExp{" TagListDz "}"        -> BExpDzVar            {cons("BExp12VarAttr")}
    VARID  ":RangeString"        -> RangeStringDzVar            {cons("RangeString12Var")}
    VARID  ":RangeString{" TagListDz "}"        -> RangeStringDzVar            {cons("RangeString12VarAttr")}
    VARID  ":SExp"        -> SExpDzVar            {cons("SExp12Var")}
    VARID  ":SExp{" TagListDz "}"        -> SExpDzVar            {cons("SExp12VarAttr")}
    VARID  ":TCPError"        -> TCPErrorDzVar            {cons("TCPError12Var")}
    VARID  ":TCPError{" TagListDz "}"        -> TCPErrorDzVar            {cons("TCPError12VarAttr")}
    VARID  ":CondName"        -> CondNameDzVar            {cons("CondName12Var")}
    VARID  ":CondName{" TagListDz "}"        -> CondNameDzVar            {cons("CondName12VarAttr")}
    VARID  ":Float"        -> FloatDzVar            {cons("Float12Var")}
    VARID  ":Float{" TagListDz "}"        -> FloatDzVar            {cons("Float12VarAttr")}
    VARID  ":IOError"        -> IOErrorDzVar            {cons("IOError12Var")}
    VARID  ":IOError{" TagListDz "}"        -> IOErrorDzVar            {cons("IOError12VarAttr")}
    VARID  ":Exps"        -> ExpsDzVar            {cons("Exps12Var")}
    VARID  ":Exps{" TagListDz "}"        -> ExpsDzVar            {cons("Exps12VarAttr")}
    VARID  ":Pgm"        -> PgmDzVar            {cons("Pgm12Var")}
    VARID  ":Pgm{" TagListDz "}"        -> PgmDzVar            {cons("Pgm12VarAttr")}
    VARID  ":Block"        -> BlockDzVar            {cons("Block12Var")}
    VARID  ":Block{" TagListDz "}"        -> BlockDzVar            {cons("Block12VarAttr")}
    VARID  ":Id"        -> IdDzVar            {cons("Id12Var")}
    VARID  ":Id{" TagListDz "}"        -> IdDzVar            {cons("Id12VarAttr")}
    VARID  ":Map"        -> MapDzVar            {cons("Map12Var")}
    VARID  ":Map{" TagListDz "}"        -> MapDzVar            {cons("Map12VarAttr")}
    VARID  ":RangeInt"        -> RangeIntDzVar            {cons("RangeInt12Var")}
    VARID  ":RangeInt{" TagListDz "}"        -> RangeIntDzVar            {cons("RangeInt12VarAttr")}
    VARID  ":#Float"        -> DzFloatDzVar            {cons("DzFloat12Var")}
    VARID  ":#Float{" TagListDz "}"        -> DzFloatDzVar            {cons("DzFloat12VarAttr")}

     K CastTypeDz "Nat"    -> VariableDz    {cons("Nat1Cast")}
     K CastTypeDz "Nat{" TagListDz "}"    -> VariableDz    {cons("Nat1CastAttr")}
     K CastTypeDz "AExp"    -> VariableDz    {cons("AExp1Cast")}
     K CastTypeDz "AExp{" TagListDz "}"    -> VariableDz    {cons("AExp1CastAttr")}
     K CastTypeDz "Set"    -> VariableDz    {cons("Set1Cast")}
     K CastTypeDz "Set{" TagListDz "}"    -> VariableDz    {cons("Set1CastAttr")}
     K CastTypeDz "Variable"    -> VariableDz    {cons("Variable1Cast")}
     K CastTypeDz "Variable{" TagListDz "}"    -> VariableDz    {cons("Variable1CastAttr")}
     K CastTypeDz "Stmts"    -> VariableDz    {cons("Stmts1Cast")}
     K CastTypeDz "Stmts{" TagListDz "}"    -> VariableDz    {cons("Stmts1CastAttr")}
     K CastTypeDz "MInt"    -> VariableDz    {cons("MInt1Cast")}
     K CastTypeDz "MInt{" TagListDz "}"    -> VariableDz    {cons("MInt1CastAttr")}
     K CastTypeDz "LowerCase"    -> VariableDz    {cons("LowerCase1Cast")}
     K CastTypeDz "LowerCase{" TagListDz "}"    -> VariableDz    {cons("LowerCase1CastAttr")}
     K CastTypeDz "CamelCaseId"    -> VariableDz    {cons("CamelCaseId1Cast")}
     K CastTypeDz "CamelCaseId{" TagListDz "}"    -> VariableDz    {cons("CamelCaseId1CastAttr")}
     K CastTypeDz "String"    -> VariableDz    {cons("String1Cast")}
     K CastTypeDz "String{" TagListDz "}"    -> VariableDz    {cons("String1CastAttr")}
     K CastTypeDz "Int"    -> VariableDz    {cons("Int1Cast")}
     K CastTypeDz "Int{" TagListDz "}"    -> VariableDz    {cons("Int1CastAttr")}
     K CastTypeDz "Stmt"    -> VariableDz    {cons("Stmt1Cast")}
     K CastTypeDz "Stmt{" TagListDz "}"    -> VariableDz    {cons("Stmt1CastAttr")}
     K CastTypeDz "Bool"    -> VariableDz    {cons("Bool1Cast")}
     K CastTypeDz "Bool{" TagListDz "}"    -> VariableDz    {cons("Bool1CastAttr")}
     K CastTypeDz "Char"    -> VariableDz    {cons("Char1Cast")}
     K CastTypeDz "Char{" TagListDz "}"    -> VariableDz    {cons("Char1CastAttr")}
     K CastTypeDz "Ids"    -> VariableDz    {cons("Ids1Cast")}
     K CastTypeDz "Ids{" TagListDz "}"    -> VariableDz    {cons("Ids1CastAttr")}
     K CastTypeDz "List"    -> VariableDz    {cons("List1Cast")}
     K CastTypeDz "List{" TagListDz "}"    -> VariableDz    {cons("List1CastAttr")}
     K CastTypeDz "Stream"    -> VariableDz    {cons("Stream1Cast")}
     K CastTypeDz "Stream{" TagListDz "}"    -> VariableDz    {cons("Stream1CastAttr")}
     K CastTypeDz "TCPAnswer"    -> VariableDz    {cons("TCPAnswer1Cast")}
     K CastTypeDz "TCPAnswer{" TagListDz "}"    -> VariableDz    {cons("TCPAnswer1CastAttr")}
     K CastTypeDz "#Int"    -> VariableDz    {cons("DzInt1Cast")}
     K CastTypeDz "#Int{" TagListDz "}"    -> VariableDz    {cons("DzInt1CastAttr")}
     K CastTypeDz "#String"    -> VariableDz    {cons("DzString1Cast")}
     K CastTypeDz "#String{" TagListDz "}"    -> VariableDz    {cons("DzString1CastAttr")}
     K CastTypeDz "#Bool"    -> VariableDz    {cons("DzBool1Cast")}
     K CastTypeDz "#Bool{" TagListDz "}"    -> VariableDz    {cons("DzBool1CastAttr")}
     K CastTypeDz "PascalCaseId"    -> VariableDz    {cons("PascalCaseId1Cast")}
     K CastTypeDz "PascalCaseId{" TagListDz "}"    -> VariableDz    {cons("PascalCaseId1CastAttr")}
     K CastTypeDz "Blocks"    -> VariableDz    {cons("Blocks1Cast")}
     K CastTypeDz "Blocks{" TagListDz "}"    -> VariableDz    {cons("Blocks1CastAttr")}
     K CastTypeDz "UpperCase"    -> VariableDz    {cons("UpperCase1Cast")}
     K CastTypeDz "UpperCase{" TagListDz "}"    -> VariableDz    {cons("UpperCase1CastAttr")}
     K CastTypeDz "BExp"    -> VariableDz    {cons("BExp1Cast")}
     K CastTypeDz "BExp{" TagListDz "}"    -> VariableDz    {cons("BExp1CastAttr")}
     K CastTypeDz "RangeString"    -> VariableDz    {cons("RangeString1Cast")}
     K CastTypeDz "RangeString{" TagListDz "}"    -> VariableDz    {cons("RangeString1CastAttr")}
     K CastTypeDz "SExp"    -> VariableDz    {cons("SExp1Cast")}
     K CastTypeDz "SExp{" TagListDz "}"    -> VariableDz    {cons("SExp1CastAttr")}
     K CastTypeDz "TCPError"    -> VariableDz    {cons("TCPError1Cast")}
     K CastTypeDz "TCPError{" TagListDz "}"    -> VariableDz    {cons("TCPError1CastAttr")}
     K CastTypeDz "CondName"    -> VariableDz    {cons("CondName1Cast")}
     K CastTypeDz "CondName{" TagListDz "}"    -> VariableDz    {cons("CondName1CastAttr")}
     K CastTypeDz "Float"    -> VariableDz    {cons("Float1Cast")}
     K CastTypeDz "Float{" TagListDz "}"    -> VariableDz    {cons("Float1CastAttr")}
     K CastTypeDz "IOError"    -> VariableDz    {cons("IOError1Cast")}
     K CastTypeDz "IOError{" TagListDz "}"    -> VariableDz    {cons("IOError1CastAttr")}
     K CastTypeDz "Exps"    -> VariableDz    {cons("Exps1Cast")}
     K CastTypeDz "Exps{" TagListDz "}"    -> VariableDz    {cons("Exps1CastAttr")}
     K CastTypeDz "Pgm"    -> VariableDz    {cons("Pgm1Cast")}
     K CastTypeDz "Pgm{" TagListDz "}"    -> VariableDz    {cons("Pgm1CastAttr")}
     K CastTypeDz "Block"    -> VariableDz    {cons("Block1Cast")}
     K CastTypeDz "Block{" TagListDz "}"    -> VariableDz    {cons("Block1CastAttr")}
     K CastTypeDz "Id"    -> VariableDz    {cons("Id1Cast")}
     K CastTypeDz "Id{" TagListDz "}"    -> VariableDz    {cons("Id1CastAttr")}
     K CastTypeDz "Map"    -> VariableDz    {cons("Map1Cast")}
     K CastTypeDz "Map{" TagListDz "}"    -> VariableDz    {cons("Map1CastAttr")}
     K CastTypeDz "RangeInt"    -> VariableDz    {cons("RangeInt1Cast")}
     K CastTypeDz "RangeInt{" TagListDz "}"    -> VariableDz    {cons("RangeInt1CastAttr")}
     K CastTypeDz "#Float"    -> VariableDz    {cons("DzFloat1Cast")}
     K CastTypeDz "#Float{" TagListDz "}"    -> VariableDz    {cons("DzFloat1CastAttr")}
     NatDzVar   -> Nat
     AExpDzVar   -> AExp
     SetDzVar   -> Set
     VariableDzVar   -> Variable
     StmtsDzVar   -> Stmts
     MIntDzVar   -> MInt
     LowerCaseDzVar   -> LowerCase
     CamelCaseIdDzVar   -> CamelCaseId
     StringDzVar   -> String
     IntDzVar   -> Int
     StmtDzVar   -> Stmt
     BoolDzVar   -> Bool
     CharDzVar   -> Char
     IdsDzVar   -> Ids
     ListDzVar   -> List
     StreamDzVar   -> Stream
     TCPAnswerDzVar   -> TCPAnswer
     DzIntDzVar   -> DzInt
     DzStringDzVar   -> DzString
     DzBoolDzVar   -> DzBool
     PascalCaseIdDzVar   -> PascalCaseId
     BlocksDzVar   -> Blocks
     UpperCaseDzVar   -> UpperCase
     BExpDzVar   -> BExp
     RangeStringDzVar   -> RangeString
     SExpDzVar   -> SExp
     TCPErrorDzVar   -> TCPError
     CondNameDzVar   -> CondName
     FloatDzVar   -> Float
     IOErrorDzVar   -> IOError
     ExpsDzVar   -> Exps
     PgmDzVar   -> Pgm
     BlockDzVar   -> Block
     IdDzVar   -> Id
     MapDzVar   -> Map
     RangeIntDzVar   -> RangeInt
     DzFloatDzVar   -> DzFloat
     K CastTypeDz "K"                         -> VariableDz    {cons("K1Cast")}
     K CastTypeDz "KItem"                     -> VariableDz    {cons("KItem1Cast")}
     K CastTypeDz "K{" TagListDz "}"        -> VariableDz    {cons("K1CastAttr")}
     K CastTypeDz "KItem{" TagListDz "}"    -> VariableDz    {cons("KItem1CastAttr")}

    VariableDz -> K


    DzDzString        -> DzString    {cons("DzString1Const")}
    DzDzBool        -> DzBool    {cons("DzBool1Const")}
    DzKLabel        -> KLabel    {cons("KLabel1Const")}
    DzDzInt        -> DzInt    {cons("DzInt1Const")}
    DzDzId        -> DzId    {cons("DzId1Const")}
    DzDzFloat        -> DzFloat    {cons("DzFloat1Const")}


context-free restrictions
    NatDzVar -/- [a-zA-Z0-9]
    AExpDzVar -/- [a-zA-Z0-9]
    SetDzVar -/- [a-zA-Z0-9]
    VariableDzVar -/- [a-zA-Z0-9]
    StmtsDzVar -/- [a-zA-Z0-9]
    MIntDzVar -/- [a-zA-Z0-9]
    LowerCaseDzVar -/- [a-zA-Z0-9]
    CamelCaseIdDzVar -/- [a-zA-Z0-9]
    StringDzVar -/- [a-zA-Z0-9]
    IntDzVar -/- [a-zA-Z0-9]
    StmtDzVar -/- [a-zA-Z0-9]
    BoolDzVar -/- [a-zA-Z0-9]
    CharDzVar -/- [a-zA-Z0-9]
    IdsDzVar -/- [a-zA-Z0-9]
    ListDzVar -/- [a-zA-Z0-9]
    StreamDzVar -/- [a-zA-Z0-9]
    TCPAnswerDzVar -/- [a-zA-Z0-9]
    DzIntDzVar -/- [a-zA-Z0-9]
    DzStringDzVar -/- [a-zA-Z0-9]
    DzBoolDzVar -/- [a-zA-Z0-9]
    PascalCaseIdDzVar -/- [a-zA-Z0-9]
    BlocksDzVar -/- [a-zA-Z0-9]
    UpperCaseDzVar -/- [a-zA-Z0-9]
    BExpDzVar -/- [a-zA-Z0-9]
    RangeStringDzVar -/- [a-zA-Z0-9]
    SExpDzVar -/- [a-zA-Z0-9]
    TCPErrorDzVar -/- [a-zA-Z0-9]
    CondNameDzVar -/- [a-zA-Z0-9]
    FloatDzVar -/- [a-zA-Z0-9]
    IOErrorDzVar -/- [a-zA-Z0-9]
    ExpsDzVar -/- [a-zA-Z0-9]
    PgmDzVar -/- [a-zA-Z0-9]
    BlockDzVar -/- [a-zA-Z0-9]
    IdDzVar -/- [a-zA-Z0-9]
    MapDzVar -/- [a-zA-Z0-9]
    RangeIntDzVar -/- [a-zA-Z0-9]
    DzFloatDzVar -/- [a-zA-Z0-9]
    VariableDz -/- [a-zA-Z0-9]
lexical syntax
    "Infinity" -> DzDzFloat
    "true" -> DzDzBool
    "'#andBool" -> DzKLabel
    "#token" -> DzKLabel
    "#symEqualitySort" -> DzKLabel
    "false" -> DzDzBool
    "NaN" -> DzDzFloat
    "isBinder" -> DzKLabel


%% sort predicates
    "isNat"      -> DzKLabel
    "isSymbolicNat"      -> DzKLabel
    "#symNat"      -> DzKLabel
    "isAExp"      -> DzKLabel
    "isSymbolicAExp"      -> DzKLabel
    "#symAExp"      -> DzKLabel
    "isSet"      -> DzKLabel
    "isSymbolicSet"      -> DzKLabel
    "#symSet"      -> DzKLabel
    "isVariable"      -> DzKLabel
    "isSymbolicVariable"      -> DzKLabel
    "#symVariable"      -> DzKLabel
    "isStmts"      -> DzKLabel
    "isSymbolicStmts"      -> DzKLabel
    "#symStmts"      -> DzKLabel
    "isMInt"      -> DzKLabel
    "isSymbolicMInt"      -> DzKLabel
    "#symMInt"      -> DzKLabel
    "isLowerCase"      -> DzKLabel
    "isSymbolicLowerCase"      -> DzKLabel
    "#symLowerCase"      -> DzKLabel
    "isCamelCaseId"      -> DzKLabel
    "isSymbolicCamelCaseId"      -> DzKLabel
    "#symCamelCaseId"      -> DzKLabel
    "isSymbolicK"      -> DzKLabel
    "#symK"      -> DzKLabel
    "isString"      -> DzKLabel
    "isSymbolicString"      -> DzKLabel
    "#symString"      -> DzKLabel
    "isInt"      -> DzKLabel
    "isSymbolicInt"      -> DzKLabel
    "#symInt"      -> DzKLabel
    "isStmt"      -> DzKLabel
    "isSymbolicStmt"      -> DzKLabel
    "#symStmt"      -> DzKLabel
    "isBool"      -> DzKLabel
    "isSymbolicBool"      -> DzKLabel
    "#symBool"      -> DzKLabel
    "isChar"      -> DzKLabel
    "isSymbolicChar"      -> DzKLabel
    "#symChar"      -> DzKLabel
    "isIds"      -> DzKLabel
    "isSymbolicIds"      -> DzKLabel
    "#symIds"      -> DzKLabel
    "isList"      -> DzKLabel
    "isSymbolicList"      -> DzKLabel
    "#symList"      -> DzKLabel
    "isStream"      -> DzKLabel
    "isSymbolicStream"      -> DzKLabel
    "#symStream"      -> DzKLabel
    "isTCPAnswer"      -> DzKLabel
    "isSymbolicTCPAnswer"      -> DzKLabel
    "#symTCPAnswer"      -> DzKLabel
    "is#Int"      -> DzKLabel
    "is#String"      -> DzKLabel
    "is#Bool"      -> DzKLabel
    "isPascalCaseId"      -> DzKLabel
    "isSymbolicPascalCaseId"      -> DzKLabel
    "#symPascalCaseId"      -> DzKLabel
    "isBlocks"      -> DzKLabel
    "isSymbolicBlocks"      -> DzKLabel
    "#symBlocks"      -> DzKLabel
    "isUpperCase"      -> DzKLabel
    "isSymbolicUpperCase"      -> DzKLabel
    "#symUpperCase"      -> DzKLabel
    "isBExp"      -> DzKLabel
    "isSymbolicBExp"      -> DzKLabel
    "#symBExp"      -> DzKLabel
    "isRangeString"      -> DzKLabel
    "isSymbolicRangeString"      -> DzKLabel
    "#symRangeString"      -> DzKLabel
    "isSExp"      -> DzKLabel
    "isSymbolicSExp"      -> DzKLabel
    "#symSExp"      -> DzKLabel
    "isKResult"      -> DzKLabel
    "isSymbolicKResult"      -> DzKLabel
    "#symKResult"      -> DzKLabel
    "isTCPError"      -> DzKLabel
    "isSymbolicTCPError"      -> DzKLabel
    "#symTCPError"      -> DzKLabel
    "isCondName"      -> DzKLabel
    "isSymbolicCondName"      -> DzKLabel
    "#symCondName"      -> DzKLabel
    "isFloat"      -> DzKLabel
    "isSymbolicFloat"      -> DzKLabel
    "#symFloat"      -> DzKLabel
    "isIOError"      -> DzKLabel
    "isSymbolicIOError"      -> DzKLabel
    "#symIOError"      -> DzKLabel
    "isExps"      -> DzKLabel
    "isSymbolicExps"      -> DzKLabel
    "#symExps"      -> DzKLabel
    "isPgm"      -> DzKLabel
    "isSymbolicPgm"      -> DzKLabel
    "#symPgm"      -> DzKLabel
    "isBlock"      -> DzKLabel
    "isSymbolicBlock"      -> DzKLabel
    "#symBlock"      -> DzKLabel
    "isId"      -> DzKLabel
    "isSymbolicId"      -> DzKLabel
    "#symId"      -> DzKLabel
    "isMap"      -> DzKLabel
    "isSymbolicMap"      -> DzKLabel
    "#symMap"      -> DzKLabel
    "isSymbolicKItem"      -> DzKLabel
    "#symKItem"      -> DzKLabel
    "isRangeInt"      -> DzKLabel
    "isSymbolicRangeInt"      -> DzKLabel
    "#symRangeInt"      -> DzKLabel
    "is#Float"      -> DzKLabel



%% terminals reject
    "ALPHABETIC" -> VARID {reject}
    "K2String" -> VARID {reject}
    "Int2Float" -> VARID {reject}
    "ARE" -> VARID {reject}
    "THEN" -> VARID {reject}
    "String2Base" -> VARID {reject}
    "Base2String" -> VARID {reject}
    "KLabel2String" -> VARID {reject}
    "Bag2String" -> VARID {reject}
    "Infinity" -> VARID {reject}
    "SMTCall" -> VARID {reject}
    "String2Bool" -> VARID {reject}
    "ZERO" -> VARID {reject}
    "String2K" -> VARID {reject}
    "NOT" -> VARID {reject}
    "POSITIVE" -> VARID {reject}
    "String2Bag" -> VARID {reject}
    "NaN" -> VARID {reject}
    "String2Int" -> VARID {reject}
    "ListItem" -> VARID {reject}
    "K2SMTLib" -> VARID {reject}
    "Float2Int" -> VARID {reject}
    "ELSE" -> VARID {reject}
    "IF" -> VARID {reject}
    "Float2String" -> VARID {reject}
    "IS" -> VARID {reject}
    "String2DotK" -> VARID {reject}
    "String2Id" -> VARID {reject}
    "VALUES" -> VARID {reject}
    "NUMERIC" -> VARID {reject}
    "K2Sort" -> VARID {reject}
    "String2Float" -> VARID {reject}
    "SMTLibQuery" -> VARID {reject}
    "String2KLabel" -> VARID {reject}
    "VALUE" -> VARID {reject}
    "THRU" -> VARID {reject}
    "Vars2SMTLib" -> VARID {reject}
    "Int2String" -> VARID {reject}
    "Consts2SMTLib" -> VARID {reject}
    "AND" -> VARID {reject}
    "NEGATIVE" -> VARID {reject}
    "Char2String" -> VARID {reject}
    "String2Char" -> VARID {reject}
    "Id2String" -> VARID {reject}
    "OR" -> VARID {reject}
    "SetItem" -> VARID {reject}

lexical restrictions
    %% follow restrictions
    "==" -/- [I].[n].[t]
    "*" -/- [F].[l].[o].[a].[t]
    "=" -/- [K].[L].[a].[b].[e].[l]
    "/" -/- [I].[n].[t]
    "==" -/- [K]
    "mi" -/- [M].[I].[n].[t]
    "==" -/- [B].[a].[g]
    "-" -/- [F].[l].[o].[a].[t]
    "replace" -/- [A].[l].[l]
    "=" -/- [K]
    "=/=K" -/- [L].[a].[b].[e].[l]
    "#freshSym" -/- [N]
    "=K" -/- [L].[a].[b].[e].[l]
    ">=" -/- [S].[t].[r].[i].[n].[g]
    ">=" -/- [I].[n].[t]
    "=" -/- [L].[i].[s].[t]
    "==K" -/- [L].[a].[b].[e].[l]
    "#freshSymSort" -/- [N]
    "<=" -/- [S].[e].[t]
    "#system" -/- [R].[e].[s].[u].[l].[t]
    "=" -/- [B].[a].[g]
    "+" -/- [I].[n].[t]
    "=" -/- [K].[L].[i].[s].[t]
    "-" -/- [I].[n].[t]
    "#parse" -/- [I].[n].[p].[u].[t]
    "#parse" -/- [T].[o].[k].[e].[n]
    "+" -/- [S].[t].[r].[i].[n].[g]
    "=" -/- [I].[n].[t]
    "." -/- [S].[e].[t]
    "==" -/- [S].[t].[r].[i].[n].[g]
    "<=" -/- [I].[n].[t]
    "-" -/- [S].[e].[t]
    "=/=K" -/- [L].[i].[s].[t]
    "<" -/- [I].[n].[t]
    "#token" -/- [T].[o].[S].[t].[r].[i].[n].[g]
    "=" -/- [S].[e].[t]
    "=K" -/- [L].[i].[s].[t]
    ">=" -/- [F].[l].[o].[a].[t]
    "==" -/- [B].[o].[o].[l]
    "-" -/- [M].[a].[p]
    ">" -/- [I].[n].[t]
    "String2K" -/- [L].[a].[b].[e].[l]
    "==K" -/- [L].[i].[s].[t]
    "VALUE" -/- [S]
    "in" -/- [K].[L].[i].[s].[t]
    "==" -/- [K].[L].[i].[s].[t]
    "fresh" -/- [I].[d]
    "." -/- [M].[a].[p]
    "<=" -/- [S].[t].[r].[i].[n].[g]
    "#system" -/- [T].[y].[p].[e].[s]
    "*" -/- [I].[n].[t]
    "#freshSym" -/- [S].[o].[r].[t].[N]
    "==" -/- [F].[l].[o].[a].[t]
    ">" -/- [F].[l].[o].[a].[t]
    "." -/- [L].[i].[s].[t]
    "+" -/- [F].[l].[o].[a].[t]
    "fresh" -/- [I].[n].[t]
    "<" -/- [S].[t].[r].[i].[n].[g]
    "<=" -/- [M].[a].[p]
    "==" -/- [K].[L].[a].[b].[e].[l]
    "#parse" -/- [I].[n].[M].[o].[d].[u].[l].[e]
    "replace" -/- [F].[i].[r].[s].[t]
    ">" -/- [S].[t].[r].[i].[n].[g]
    "<" -/- [F].[l].[o].[a].[t]
    "#stat" -/- [T].[y].[p].[e].[s]
    "#freshSym" -/- [S].[o].[r].[t]
    "<=" -/- [F].[l].[o].[a].[t]
    "/" -/- [F].[l].[o].[a].[t]
    "=" -/- [M].[a].[p]
lexical restrictions
%% some restrictions to ensure greedy matching for user defined constants
    "is" -/- [\#A-Z]

lexical syntax
    [\-\+]? [0-9]+ -> DzIntDz
    "88" -> DzIntDz {reject}
    [\+\-]?[0-9]+"."[0-9]+([eE][\+\-]?[0-9]+)?([fFdD]|([pP][0-9]+[xX][0-9]+))? -> DzFloatDz
    [\+\-]?"Infinity"([fFdD]|([pP][0-9]+[xX][0-9]+))? -> DzFloatDz
    "Infinity" -> DzFloatDz {reject}
    "NaN"([fFdD]|([pP][0-9]+[xX][0-9]+))? -> DzFloatDz
    "NaN" -> DzFloatDz {reject}
    "\"" ((~[\"\n\r\\]) | (((([\\][nrtf\"\\]) | ([\\][x][0-9a-fA-F][0-9a-fA-F])) | ([\\][u][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])) | ([\\][U][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])))* "\"" -> DzStringDz
context-free syntax
    DzStringDz -> DzString {cons("DzString1Const")}
    DzIntDz -> DzInt {cons("DzInt1Const")}
    DzFloatDz -> DzFloat {cons("DzFloat1Const")}


context-free restrictions
    "#" -/- [s].[y].[m]
    DzInt -/-  [0-9]
